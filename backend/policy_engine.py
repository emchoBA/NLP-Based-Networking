import logging
# Assuming nlp.py is in the same 'backend' package
from . import nlp  # Relative import for sibling module in package
# Import new components
from .policy_components.rule_interpreter import RuleInterpreter
from .policy_components.iptables_command_builder import IPTablesCommandBuilder, SERVICES_TO_IGNORE

log = logging.getLogger(__name__)


class PolicyEngine:
    def __init__(self):
        self.rule_interpreter = RuleInterpreter()
        self.command_builder = IPTablesCommandBuilder()
        # Ensure NLP model is loaded (nlp.py handles its own loading)
        if not hasattr(nlp, 'nlp') or nlp.nlp is None:
            log.error("[PolicyEngine] NLP model from nlp.py not available!")
            # Consider raising an exception or setting a failed state

    def parse_and_generate_commands(self, nl_text: str, preferred_target_ip: str | None = None) -> list[
        tuple[str, str | None, str | None, list[str]]]:
        """
        Orchestrates parsing NL text, interpreting rules, and generating iptables commands.

        Args:
            nl_text: The natural language policy string.
            preferred_target_ip: Optional IP from GUI selection.

        Returns:
            A list of tuples: (final_target_ip, source_ip, destination_ip, list_of_commands)
        """
        log.debug(f"[PolicyEngine] Orchestrating for: '{nl_text}', Preferred Target: {preferred_target_ip}")

        try:
            nlp_rules = nlp.parse_commands(nl_text)
        except Exception as e:
            log.error(f"[PolicyEngine] Error during NLP parsing: {e}")
            # Potentially raise this or return empty to signal critical failure
            return []

        if not nlp_rules:
            log.warning("[PolicyEngine] NLP parsing yielded no rules.")
            return []

        all_generated_tuples = []

        for i, nlp_rule_dict in enumerate(nlp_rules):
            log.debug(f"[PolicyEngine] Processing NLP Rule {i + 1}: {nlp_rule_dict}")

            interpreted_rule_details = self.rule_interpreter.determine_final_target_and_chain(
                nlp_rule_dict, preferred_target_ip
            )

            if not interpreted_rule_details:
                log.warning(f"[PolicyEngine] Rule {i + 1} could not be interpreted (no target/chain). Skipping.")
                continue

            # Validate essential parts from interpreter
            if not interpreted_rule_details.get('action') or \
                    not (interpreted_rule_details.get('source_ip') or interpreted_rule_details.get('destination_ip')):
                # This check might be redundant if RuleInterpreter already filters, but good for safety.
                # Or if only a very generic service like "any" is present with no IPs.
                # The command builder will handle cases where IPs are missing for certain services.
                if not interpreted_rule_details.get('service') or \
                        interpreted_rule_details.get(
                            'service').lower() not in SERVICES_TO_IGNORE:
                    log.warning(
                        f"[PolicyEngine] Interpreted Rule {i + 1} ({interpreted_rule_details.get('final_target_ip')}) "
                        f"is incomplete for command generation (missing action or specific IP context for non-generic service). Skipping."
                    )
                    continue

            commands_for_this_rule = self.command_builder.build_commands(interpreted_rule_details)

            if commands_for_this_rule:
                final_target = interpreted_rule_details["final_target_ip"]
                src_ip = interpreted_rule_details["source_ip"]
                dest_ip = interpreted_rule_details["destination_ip"]
                log.info(
                    f"[PolicyEngine] For Rule {i + 1}, generated {len(commands_for_this_rule)} cmd(s). "
                    f"Target: {final_target}, Src: {src_ip}, Dest: {dest_ip}"
                )
                all_generated_tuples.append(
                    (final_target, src_ip, dest_ip, commands_for_this_rule)
                )
            else:
                log.warning(
                    f"[PolicyEngine] No commands generated by CommandBuilder for interpreted rule: {interpreted_rule_details}")

        return all_generated_tuples


# --- For external use (e.g., by GUI's PolicyManager) ---
# We can expose a single instance or a function that uses an instance.
_policy_engine_instance = None


def get_policy_engine_instance():
    """Returns a singleton instance of the PolicyEngine."""
    global _policy_engine_instance
    if _policy_engine_instance is None:
        _policy_engine_instance = PolicyEngine()
    return _policy_engine_instance


def parse_and_generate_commands_for_gui(nl_text: str, preferred_target_ip: str | None = None):
    """
    Convenience function for the GUI to call.
    Uses a singleton PolicyEngine instance.
    """
    engine = get_policy_engine_instance()
    return engine.parse_and_generate_commands(nl_text, preferred_target_ip)


# Example usage (if run directly - ensure paths are correct for imports)
if __name__ == "__main__":
    # Setup basic logging for standalone testing
    logging.basicConfig(level=logging.DEBUG,
                        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

    # Ensure backend sibling modules can be imported (adjust sys.path if needed for standalone)
    # import sys
    # import os
    # SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
    # PARENT_DIR = os.path.dirname(SCRIPT_DIR) # This would be 'backend'
    # GRANDPARENT_DIR = os.path.dirname(PARENT_DIR) # This would be 'playground_project'
    # if GRANDPARENT_DIR not in sys.path:
    #    sys.path.append(GRANDPARENT_DIR)
    # print(f"Sys.path for standalone policy_engine: {sys.path}")

    # Re-import nlp with adjusted path if necessary (though direct run might fail complex imports)
    # from backend import nlp # This might fail if not run as part of package
    # from backend import service_mapper
    # from backend import alias_manager

    # Test requires nlp, service_mapper, alias_manager to be importable.
    # This direct run might be tricky due to package structure.
    # It's better to test by running the main admin_app.

    print("--- Policy Engine Standalone Test (limited due to package imports) ---")
    test_engine = PolicyEngine()  # Will try to init NLP

    # Sample test (NLP part might not fully work if model isn't found easily here)
    if hasattr(nlp, 'nlp') and nlp.nlp is not None:
        # Setup some aliases for testing if alias_manager is available
        try:
            from . import alias_manager  # Try relative import for alias_manager

            alias_manager.add_alias("192.168.1.100", "MyServer")
            alias_manager.add_alias("192.168.1.200", "AttackerPC")
        except ImportError:
            print("WARN: alias_manager not available for standalone test.")

        test_nl1 = "on MyServer deny ssh from AttackerPC"
        preferred1 = "192.168.1.11"  # Should be ignored if MyServer resolves
        print(f"\n--- Test 1: '{test_nl1}' with Preferred Target '{preferred1}' ---")
        commands1 = test_engine.parse_and_generate_commands(test_nl1, preferred_target_ip=preferred1)
        for t_ip, s_ip, d_ip, c_list in commands1:
            print(f"  Target: {t_ip}, Src: {s_ip}, Dest: {d_ip}, Cmds: {c_list}")

        test_nl2 = "allow http to 10.0.0.5"
        preferred2 = "192.168.1.50"  # Should override if NLP target is implicit
        print(f"\n--- Test 2: '{test_nl2}' with Preferred Target '{preferred2}' ---")
        commands2 = test_engine.parse_and_generate_commands(test_nl2, preferred_target_ip=preferred2)
        for t_ip, s_ip, d_ip, c_list in commands2:
            print(f"  Target: {t_ip}, Src: {s_ip}, Dest: {d_ip}, Cmds: {c_list}")
    else:
        print("NLP model not loaded, cannot run full tests from policy_engine standalone.")